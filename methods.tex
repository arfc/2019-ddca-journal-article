\section{Methodology}
%Description of D3ploy
In \Cyclus, developers have the option to design 
agents using C++ or Python. 
The \deploy \texttt{Institution} agent was 
implemented in Python to enable the use of 
well developed time series forecasting Python packages. 

In a \Cyclus \gls{NFC} simulation, at every time step \deploy 
predicts supply and demand of each commodity for the next time 
step. 
If undersupply is predicted for any commodity,
\deploy deploys facilities to meet its predicted demand.  
Figure \ref{fig:flow} shows the logic flow of \deploy 
at every time step. 

\begin{figure}[]
	\centering
	\resizebox{0.8\textwidth} {0.8\height}{
    \begin{tikzpicture}[node distance=2.5cm]
    \tikzstyle{every node}=[font=\large]
	\node (Start) [bblock] {\textbf{Start of time step ($t$).}};
	\node (Predict) [bblock, below of=Start] {\textbf{Calculate \\ $D_p(t+1)$ and $S_p(t+1)$ for a commodity}};
	\node (IsThere) [oblock, below of=Predict]{\textbf{$U(t+1) = S_p(t+1)-D_p(t+1)$}};
	\node (Deploy) [bblock, below of=IsThere, xshift = -3.5cm]{\textbf{Deployment of facility}};
    \node (NoDeploy) [bblock, right of=Deploy, xshift = 3.5cm]{\textbf{No Deployment} };
    \node (All) [oblock, below of=Deploy, xshift = 3.5cm] {\textbf{Is this done for all commodities?}};
    \node (End) [bblock, below of=All] {\textbf{Proceed to next time step.}};
	
	\draw [arrow] (Start) -- (Predict); 
	\draw [arrow] (Predict) -- (IsThere);
    \draw [arrow] (IsThere) -- node[anchor=east] {$U(t+1) <$ buffer} (Deploy);
    \draw [arrow] (IsThere) -- node[anchor=west] {$U(t+1) \geq$ buffer} (NoDeploy);
    \draw [arrow] (Deploy) -- (All);
    \draw [arrow] (NoDeploy) -- (All);
    \draw [arrow] (All) -- node[anchor=west] {yes} (End);
    \draw [arrow] (All) -- ([shift={(-3.9cm,0.7cm)}]All.south west)-- node[anchor=east] {no} ([shift={(-3.9cm,-1cm)}]Predict.north west)--(Predict);
    \draw [arrow] (End) |-([shift={(3cm,-0.5cm)}]End.south east)-- ([shift={(3cm,0.5cm)}]Start.north east)-|(Start);
	\end{tikzpicture}
	}
    \caption{\deploy logic flow at every time step in \Cyclus \cite{chee_demonstration_2019}.}
    \label{fig:flow}
\end{figure}

\deploy's main objective is to minimize
undersupply of power. 
The sub-objectives are : (1) to minimize the number of time 
steps of undersupply or under capacity of any 
commodity, (2) to minimize excessive oversupply of all commodities.
This is a reflection of reality in which it is important to 
never have an undersupply of power on the grid by ensuring power 
plants are never short of fuel, while not 
having excessive oversupply resulting in a burden to store unused 
supplies. 
\glspl{NFCSim} often face power undersupplies at certain time steps 
due to lack of viable fuel, despite having sufficient installed 
reactor capacity.  
Therefore, using \deploy to automatically deploy supporting facilities 
will prevent this from occurring. 

\subsection{Structure}
%Description of front end and back end of fuel cycle 
%Demand Driven vs. Supply Driven 
In \deploy, two different institutions control 
front-end and back-end fuel cycle facilities: 
\texttt{DemandDrivenDeploymentInst} and 
\texttt{SupplyDrivenDeploymentInst}, respectively. 
This distinction was made because front-end facilities 
are deployed to meet demand for commodities they produce, 
whereas, back-end facilities are deployed to meet supply for the 
commodities they provide capacity for. 
For example, for front-end facilities, a reactor facility 
demands fuel and \texttt{DemandDrivenDeploymentInst} 
triggers deployment of fuel fabrication facilities to create 
supply, and thus, meeting demand for fuel to prevent undersupply. 
For back-end facilities, the reactor generates spent fuel and 
\texttt{SupplyDrivenDeploymentInst} triggers deployment of 
waste storage facilities to create capacity meeting the supply 
of spent fuel to prevent under capacity. 

\subsection{Input Variables}
Table \ref{tab:inputs} lists and gives examples of the input 
variables \deploy accepts. 
Essentially, the user must do the following: 
define the facilities controlled by \deploy and their respective 
capacities, the driving commodity and 
its demand equation, the deployment driving method, and the 
preferred prediction method. 
The user also has the option to define supply/capacity buffers 
for individual commodities, facility preferences, and facility 
constraints. 
The subsequent sections provide an 
in-depth description of the deployment driving methods, buffers, 
facility preferences, and prediction methods. 


    \begin{table}[]
        \centering
        \caption{\deploy's required and optional input parameters with examples.}
		\label{tab:inputs}
            \footnotesize
			\begin{tabularx}{\textwidth}{l|LL}
			\hline
				& \textbf{Input Parameter}                                                           & \textbf{Examples}                                                                                                          \\ \hline
				\multirow{5}{*}{\textbf{Required}} & Demand driving commodity                                                           & Power, Fuel, Plutonium, etc.                                                                                                                      \\ \cline{2-3} 
														  & Demand equation                                                                    & P(t) = 10000, sin(t), 10000*t                                                                                                                 \\ \cline{2-3} 
														  & Facilities it controls                                                             & Fuel Fab, LWR reactor, SFR reactor, Waste repository, etc.                                                                                                      \\ \cline{2-3} 
														  & Capacities of the facilities                                                       & 3000 kg, 1000 MW, 50000 kg                                                                                                     \\ \cline{2-3} 
														  & Prediction method                                                                  & \begin{tabular}[c]{@{}l@{}}Power: fast fourier transform\\ Fuel: moving average\\ Spent fuel: moving average\end{tabular} \\ \cline{2-3} 
														  & Deployment driven by & Installed Capacity/Supply                                                                                                                    \\ \hline
				\multirow{4}{*}{\textbf{Optional}} & Supply/Capacity Buffer type                                                                        & Absolute                                                                                                                  \\ \cline{2-3} 
														  & Supply/Capacity Buffer size                                                                        & \begin{tabular}[c]{@{}l@{}}Power: 3000 MW\\ Fuel: 0 kg \\ Spent fuel: 0 kg\end{tabular}                                   \\ \cline{2-3} 
														  & Facility preferences                                                               & \begin{tabular}[c]{@{}l@{}}LWR reactor = 100-t\\ SFR reactor = t-100 \end{tabular}          \\ \cline{2-3} 
														  & Facility constraint                                                              & SFR reactor constraint = 5000kg of Pu            \\ \hline	
						\end{tabularx}
    \end{table}

\subsubsection{Deployment Driving Method}
The user has the choice of deploying facilities based on the difference 
between either predicted demand and supply, or predicted demand and 
installed capacity. 
There are two advantages of using installed capacity over predicted 
supply. 
First, to prevent over-deployment of facilities with an
intermittent supply; one example would be reactor
facilities that have periodic downtimes for refueling. 
If predicted supply was selected instead of installed capacity, 
\deploy would deploy surplus reactors during refueling downtimes to 
meet the temporary power undersupply.
Second, to prevent infinite deployment of a facility that uses 
a commodity no longer available in the simulation. 
For example, in a transition scenario from \glspl{LWR} to \glspl{SFR}, 
the reprocessing plant that fabricates \gls{SFR} fuel might demand 
Pu after the existing inventory is depleted 
and all Pu-generating \glspl{LWR} have already been decommissioned. 
This will result in \deploy deploying infinite reprocessing 
facilities in a futile attempt to produce \gls{SFR} fuel, given the lack of Pu.
This can also be avoided by using \deploy's facility constraint capability 
(section \ref{sec:constrain})
to withhold \gls{SFR} deployment until a sizable inventory of Pu 
is accumulated in the simulation. 

\subsubsection{Supply/Capacity Buffer}
In \texttt{DemandDrivenDeploymentInst}, the user has the option 
to provide a supply buffer for each commodity; \deploy will account 
for the buffer when calculating predicted demand and 
deploy facilities accordingly.
In \texttt{SupplyDrivenDeployment}

\noindent 
\texttt{Inst},
the user has the option 
to provide a capacity buffer for specific commodities; 
\deploy will account 
for the buffer when calculating predicted supply and 
deploy facilities accordingly.
For example, the user could set the power commodity's supply buffer 
to be 2000 MW. 
If predicted demand is 10000 MW, \deploy will deploy reactor 
facilities to meet the predicted demand and supply buffer, resulting 
in a power supply of 12000 MW.  
The buffer can be defined as a percentage (equation \ref{eq:perc}) 
or absolute value (equation \ref{eq:abs}). 

\begin{equation}
    \label{eq:perc}
    S_{pwb} = S_{p}*(1+d)
\end{equation}
\begin{equation}
    \label{eq:abs}
    S_{pwb} = S_{p}+a
\end{equation}
where $S_{pwb}$ is predicted supply/capacity with buffer, 
$S_p$ is the predicted supply/capacity without buffer, 
$d$ is the percentage value in decimal form, 
and $a$ is the absolute value of the buffer. 

Using a combination of this buffer capability alongside the 
installed capacity deployment driving method in a transition 
scenario simulation effectively minimizes undersupply of a 
commodity while avoiding excessive oversupply. 
This is demonstrated in section \ref{sec:demo}. 

\subsection{Facility Preference and Constraint}
\label{sec:constrain}
% Need to explain the order of preferences for deployment 
% Constraint, pref, minimize number of facilities and minimize 
% over supply 
The user can elect to specify time-dependent preference equations 
for each facility; if more than one facility can supply the same 
commodity, \deploy uses these equations to determine which facility 
to deploy during a commodity shortage. 
In table \ref{tab:inputs}, 
the \gls{LWR} reactor has a preference of $100-t$ and the 
\gls{SFR} reactor has a preference of $t-100$. 
Thus, the simulation will have a preference to deploy 
\glspl{LWR} before time step 100 and \glspl{SFR} afterwards. 

The user also has the option to provide each facility with a 
commodity constraint. 
In table \ref{tab:inputs}, 
the \gls{SFR} has a commodity constraint of 5000kg of Pu. 
This constrains \gls{SFR} deployment to the size of the Pu inventory 
in the simulation. 
\glspl{SFR} are deployed only after the 5000kg minimum Pu inventory 
is satisfied. 

In many scenarios, advanced reactors are forced to idle after 
depleting the initial Pu inventory. 
In these situations, the facility preferences and constraint capabilities 
are beneficial to the user. 
An ideal transition year is selected using the facility 
preferences, however the transition will only begin when there 
is sufficient Pu inventory (set by facility constraint) 
to avoid shortages. 

Therefore, when \deploy predicts an undersupply of a commodity, 
it deploys facilities in order of preference, starting at 
the highest and moving down if the facility in question does 
not meet its constraint criteria.
If the facilities do not have preferences or constraints, \deploy 
will deploy the available facilities to minimize the number of 
deployed facilities while minimizing oversupply of the commodity.

\subsection{Prediction Methods}
\deploy records supply and demand values at each time step for all 
commodities. 
This provides time series data for \deploy's time series 
forecasting methods to predict future supply and demand for each 
commodity.  
Three main method types were investigated: non-optimizing, 
deterministic-optimizing, and stochastic-optimizing
time series forecasting methods.
Non-optimizing methods are techniques that harness 
simple moving average and autoregression concepts that use 
historical data to infer future supply and demand values. 
Deterministic-optimizing and stochastic-optimizing 
methods are techniques 
that use an assortment of more complex time series forecasting 
concepts to predict future supply and demand values. 
Deterministic-optimizing methods give deterministic solutions,
while stochastic-optimizing methods give stochastic solutions. 

Depending on the scenario in question, each forecasting method 
offers its own distinct benefits and disadvantages.
The various methods are compared for each type of simulation 
to determine the most effective prediction method for 
a given scenario.  
The prediction methods will be described in the following 
sections. 

\subsubsection{Non-Optimizing Methods}
Non-optimizing methods include: Moving Average (\texttt{MA})
, Autoregressive Moving Average (\texttt{ARMA}), and 
Autoregressive Heteroskedasticity (\texttt{ARCH}). 
The \texttt{MA} method calculates the average of 
a user-defined number of previous entries in a commodity's 
time series and returns it as the predicted value 
(equation \ref{eq:ma}).

\begin{equation}
	\label{eq:ma}
	Predicted\ Value = \frac{V_1+V_2+...+V_n}{n}
\end{equation}

The \texttt{ARMA} method combines moving average and
autoregressive models (equation \ref{eq:arma}).
The first term is a constant, second term is 
white noise, third term is the autoregressive
model, and the fourth term is the moving average
model.
The \texttt{ARMA} method is more accurate than the 
\texttt{MA} method 
because of the inclusion of the autoregressive term. 

\begin{equation}
	\label{eq:arma}
	X_t = c + \epsilon_t + 
	\sum_{i=1}^p\varphi_i X_{t-i} +	
	\sum_{i=1}^q\theta_i\epsilon_{t-i}
\end{equation}

The \texttt{ARCH} method modifies the original moving 
average term (described in equation \ref{eq:arma}). 
This modification makes the \texttt{ARCH} method 
better than the \texttt{ARMA} method for volatile time 
series data \cite{flanagan_methods_2019}. 
The StatsModels \cite{github_community_statsmodels:_2019}
Python package is used to implement \texttt{ARMA} and 
\texttt{ARCH} methods in \deploy. 

\subsubsection{Deterministic-Optimizing Methods}
Deterministic methods include: 
Fast Fourier Transform (\texttt{FFT}), 
Polynomial Fit (\texttt{poly}), 
Exponential Smoothing (\texttt{exp-smoothing})
, and Triple Exponential Smoothing (\texttt{holt-winters}). 
The \texttt{FFT} method computes the discrete Fourier transform 
of the time series to predict future demand and supply 
values (equation \ref{eq:fft}).
This method is implemented in \deploy using the 
SciPy \cite{jones_scipy:_2016} Python package. 

\begin{equation}
	\label{eq:fft}
	X_k = \sum_{n=0}^{N-1}x_n e^{-i2\pi kn/N}
\end{equation}

The \texttt{poly} method models the time series data 
with a nth degree (user-defined) polynomial to determine 
future demand and supply values. 
This method was implemented in \deploy using the 
NumPy \cite{developers_numpy_2013} Python package. 
The \texttt{exp-smoothing} and \texttt{holt-winters} 
methods use a weighted average 
of time series data with weights decaying exponentially 
for older time series values \cite{hyndman_forecasting:_2018}
to create a model to determine future demand and supply values. 
The \texttt{exp-smoothing} method excels in 
modeling univariate time series data without trend or seasonality, 
whereas the \texttt{holt-winters} method applies exponential 
smoothing three times resulting in higher accuracy when 
modeling seasonal time series data. 
The StatsModels \cite{github_community_statsmodels:_2019}
Python package was used to implement both of these methods 
in \deploy. 

\subsection{Stochastic-Optimizing Methods}
There is one stochastic-optimizing method: step-wise 
seasonal method. 
The method was implemented in \deploy by the auto \gls{ARIMA} 
method in the pmdarima \cite{noauthor_pmdarima:_2019}
Python package. 
The \gls{ARIMA} model is a generalization of the \gls{ARMA}
model to make the model fit the time series data better. 
It replaces the time series values with the difference
between consecutive values. 

