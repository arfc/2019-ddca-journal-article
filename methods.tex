\section{Methodology}
%Description of D3ploy
In \Cyclus, developers have the option to design 
agents using C++ or Python. 
The \deploy \texttt{Institution} agent was 
implemented in Python to enable the use of 
well-developed time series forecasting Python packages. 

In a \Cyclus simulation, at every time step, \deploy 
predicts the supply and demand of each commodity for the next time 
step. 
Commodities refer to materials in the nuclear fuel cycle such as 
reactor fuel. 
Upon undersupply for any commodity, 
\deploy deploys facilities to meet its predicted demand.
Therefore, if the simulation begins with user-defined power 
demand, \deploy deploys reactors to meet power demand, 
followed by enrichment facilities to meet fuel demand, and so on,
to create the supply chain.
Based on the demand and supply trends of each commodity, 
\deploy predicts their 
future demand and supply, and deploys facilities 
accordingly to meet the future demand to prevent demand 
from surpassing supply. 
Figure \ref{fig:flow} shows the logical flow of \deploy 
at every time step. 
In subsequent subsections, we describe how to set up a 
transition scenario using \deploy and the input parameters 
\deploy accepts. 

\begin{figure}[]
	\centering
	\resizebox{0.8\textwidth} {0.8\height}{
    \begin{tikzpicture}[node distance=2.5cm]
    \tikzstyle{every node}=[font=\large]
	\node (Start) [bblock] {\textbf{Start time step ($t$).}};
	\node (Predict) [bblock, below of=Start] {\textbf{Calculate $D_p(t+1)$ and $S_p(t+1)$ for a commodity}};
	\node (IsThere) [oblock, below of=Predict]{\textbf{$U(t+1) = S_p(t+1)-D_p(t+1)$}};
	\node (Deploy) [bblock, below of=IsThere, xshift = -3.5cm]{\textbf{Deploy Facilities}};
    \node (NoDeploy) [bblock, right of=Deploy, xshift = 3.5cm]{\textbf{No Deployment} };
    \node (All) [oblock, below of=Deploy, xshift = 3.5cm] {\textbf{Has $D_p(t+1)$ and \\ $S_p(t+1)$ been calculated for all commodities?}};
    \node (End) [bblock, below of=All] {\textbf{Proceed to next time step.}};
	
	\draw [arrow] (Start) -- (Predict); 
	\draw [arrow] (Predict) -- (IsThere);
    \draw [arrow] (IsThere) -- node[anchor=east] {$U(t+1) <$ buffer} (Deploy);
    \draw [arrow] (IsThere) -- node[anchor=west] {$U(t+1) \geq$ buffer} (NoDeploy);
    \draw [arrow] (Deploy) -- (All);
    \draw [arrow] (NoDeploy) -- (All);
    \draw [arrow] (All) -- node[anchor=west] {yes} (End);
    \draw [arrow] (All) -- ([shift={(-4cm,1cm)}]All.south west)-- node[anchor=east] {no} ([shift={(-4cm,-0.8cm)}]Predict.north west)--(Predict);
    \draw [arrow] (End) |-([shift={(3cm,-0.5cm)}]End.south east)-- ([shift={(3cm,0.5cm)}]Start.north east)-|(Start);
	\end{tikzpicture}
	}
    \caption{\deploy logic flow at every time step in \Cyclus \cite{chee_demonstration_2019}.}
    \label{fig:flow}
\end{figure}

\deploy aims to minimize the undersupply of power:
\begin{align}
	\label{eq:pow}
	obj &= min \sum_{t=1}^{t_{f}} |D_{t,p}-S_{t,p}|.
	\intertext{where:}
	D &= \mbox{Demand} \nonumber\\
	S &= \mbox{Supply} \nonumber\\
	p &= \mbox{power} \nonumber \\
	t_f &= \mbox{Number of time steps} \nonumber \\
	M &= \mbox{Number of commmodities} \nonumber
\end{align} 
The sub-objectives are to minimize the number of time 
steps of undersupply or under-capacity of any 
commodity: 
\begin{align}
	\label{eq:sub1}
	obj = min \sum_{i=1}^{M}\sum_{t=1}^{t_f} |D_{t,i}-S_{t,i}|,
\end{align}
and to minimize excessive oversupply of all commodities: 
\begin{align}
	\label{eq:sub2}
	obj &= min \sum_{i=1}^{M}\sum_{t=1}^{t_f} |S_{t,i}-D_{t,i}|.
\end{align} 
Minimizing excessive oversupply 
reflects reality in which utilities avoid 
undersupply of power on the grid by ensuring power 
plants are never short of fuel while avoiding expensive oversupply.
Nuclear fuel cycle simulators often face power undersupplies 
due to lack of viable fuel, despite having sufficient installed 
reactor capacity.  
Using \deploy to automate the deployment of supporting 
facilities prevents this. 

\subsection{Structure}
%Description of front end and back end of fuel cycle 
%Demand Driven vs. Supply Driven 
In \deploy, two distinct institutions control 
front-end and back-end fuel cycle facilities: 
\texttt{DemandDrivenDeploymentInst} and 
\texttt{SupplyDrivenDeploymentInst}, respectively. 
The reason for this distinction is that front-end facilities 
meet the demand for commodities they produce, whereas back-end 
facilities meet supply for the commodities they demand. 
For example, when a reactor facility 
demands fuel, \texttt{DemandDrivenDeploymentInst}
deploys fuel fabrication facilities to create fuel
supply. 
For back-end facilities, the reactor generates spent fuel, and 
\texttt{SupplyDrivenDeploymentInst} deploys 
waste storage facilities to create capacity to store the spent fuel. 
Figure \ref{fig:insts} depicts a simple once-through fuel cycle 
and the \texttt{Institution} type governing each 
facility's deployment.  

\begin{figure}[]
	\centering
	\resizebox{\textwidth}{!}{
	\trimbox{0cm -.5cm 0cm 0cm}{ 
\begin{tikzpicture}[node distance=2.8cm,auto,>=latex']
	\tikzstyle{every node}=[font=\scriptsize]
    \node [bbslock] (a) {\textbf{Source}};
    \node [bbslock] (b) [right of=a] {\textbf{Enrichment \\ Facility}};
	\node [bbslock] (c) [right of=b] {\textbf{Reactor}};
	\node [obslock] (d) [right of=c] {\textbf{Cooling \\ Pool}};
	\node [obslock] (e) [right of=d] {\textbf{Sink}};
    \path[->] (a) edge node {\shortstack{Natl \\ U}} (b);
	\draw[->] (b) edge node {Fuel} (c) ;
	\draw[->] (c) edge node {\shortstack{Used \\ Fuel}} (d) ;
	\draw[->] (d) edge node {\shortstack{Cooled \\ Used \\ Fuel}} (e) ;
\end{tikzpicture}
	}}

\resizebox{0.5\textwidth}{!}{
    \fbox{\begin{tabular}{ll}
        \textcolor{illiniblue}{$\blacksquare$} & Deployed by \texttt{DemandDrivenDeploymentInst}\\
        \textcolor{illiniorange}{$\blacksquare$} & Deployed by \texttt{SupplyDrivenDeploymentInst} 
		\end{tabular}}}
		\caption{Simple once-through fuel cycle depicting which facilities are deployed by 
		\texttt{DemandDrivenDeploymentInst} and \texttt{SupplyDrivenDeploymentInst}.}
\label{fig:insts}
\end{figure}

\subsubsection{Deployment Driving Method}
The user may deploy facilities based on the difference 
between predicted demand and predicted supply, \textit{or}
predicted demand and installed capacity. 
Using installed capacity instead of predicted supply
has two advantages. 
First, to prevent over-deployment of facilities with an
intermittent supply such as reactors that require refueling. 
If predicted supply is selected instead of installed capacity, 
\deploy will deploy surplus reactors during refueling downtimes to 
meet the temporary power undersupply.
Second, to prevent infinite deployment of a facility that demands 
a commodity no longer available in the simulation. 
For example, a reprocessing plant that fabricates Sodium-Cooled Fast Reactor 
(SFR) fuel might demand Pu after depletion of the existing Pu inventory and 
decommissioning of the LWR reactors that produce it, resulting in 
infinite deployment of reprocessing facilities in a futile attempt 
to produce SFR fuel. 

\subsection{Input Variables}
Table \ref{tab:inputs} lists and gives examples of the input 
variables \deploy accepts. 
The user must do the following: 
define the facilities in the simulation, their respective 
capacities, the demand driving commodity,
its demand equation, the deployment driving method, 
and prediction method. 
The user also has the option to define supply/capacity buffers 
for individual commodities, facility preferences, and facility 
fleet shares.  
The subsequent sections describes 
the buffers, facility preferences, and prediction methods. 


\begin{table}[]
	\centering
    \caption{\deploy's required and optional input parameters with examples.}
    \label{tab:inputs}
        \footnotesize
        \begin{tabular}{l|ll}
        \hline
            & \textbf{Input Parameter}                                                           & \textbf{Examples}                                                                                                          \\ \hline
            \multirow{5}{*}{\textbf{Required}} & Demand driving commodity                                                           & Power                                                                                                                      \\ \cline{2-3} 
                                                      & Demand equation                                                                    & P(t) = 10000, sin(t), 10000*t                                                                                                                 \\ \cline{2-3} 
                                                      & Facilities it controls                                                             & Fuel Fab, LWR reactor, Sink, etc.                                                                                                      \\ \cline{2-3} 
                                                      & Capacities of the facilities                                                       & 3000 kg, 1000 MW, 50000 kg                                                                                                     \\ \cline{2-3} 
                                                      & Prediction method                                                                  & \begin{tabular}[c]{@{}l@{}}Power: fast fourier transform\\ Fuel: moving average\\ Spent fuel: moving average\end{tabular} \\ \cline{2-3} 
                                                      & Deployment driven by & Installed Capacity                                                                                                                    \\ \hline
            \multirow{4}{*}{\textbf{Optional}} & Supply/Capacity Buffer type                                                                        & Absolute                                                                                                                  \\ \cline{2-3} 
                                                      & Supply/Capacity Buffer size                                                                        & \begin{tabular}[c]{@{}l@{}}Power: 3000 MW\\ Fuel: 0 kg \\ Spent fuel: 0 kg\end{tabular}                                   \\ \cline{2-3} 
                                                      & Facility preferences                                                               & \begin{tabular}[c]{@{}l@{}}LWR reactor = 100-t\\ SFR reactor = t-99 \end{tabular}          \\ \cline{2-3} 
                                                      & Fleet share percentage                                                            & \begin{tabular}[c]{@{}l@{}}MOX LWR = 85\%\\ SFR = 15\% \end{tabular}          \\ \hline
                    \end{tabular}
\end{table}
\subsubsection{Supply/Capacity Buffer}
In \texttt{DemandDrivenDeploymentInst}, the user has the option to specify a 
supply buffer for each commodity; \deploy accounts for the buffer when 
calculating predicted demand and deploys facilities accordingly.
In \texttt{SupplyDrivenDeployment}

\noindent 
\texttt{Inst},
the user has the option to specify a capacity buffer for specific 
commodities; d3ploy accounts for the buffer when calculating predicted 
supply and deploys facilities accordingly. 
The buffer is defined as a percentage (equation \ref{eq:perc}) 
or absolute value (equation \ref{eq:abs}). 

\begin{align}
    \label{eq:perc}
	S_{pwb} &= S_{p}(1+d)\\
	\label{eq:abs}
	S_{pwb} &= S_{p}+b \\
	\intertext{where:}
	S_{pwb} &= \mbox{predicted supply/capacity with buffer} \nonumber\\
	S_p &= \mbox{predicted supply/capacity} \nonumber\\
	d &= \mbox{percentage value in decimal form} \nonumber\\
    b &= \mbox{absolute value of the buffer} \nonumber
\end{align}
For example, the user sets the power commodity's absolute supply buffer 
to be 2000 MW and predicted demand is 10000 MW, \deploy deploys reactor 
facilities to meet the predicted demand and supply buffer, resulting 
in a power supply of: 
\begin{align*}
	S_{pwb} &= S_{p}+a \\
	S_{pwb} &= 10000 \mbox{MW}+2000 \mbox{MW} \\
	&= 12000\mbox{MW}
\end{align*}
Using the buffer capability and  
installed capacity to drive facility deployment in a transition 
scenario simulation will effectively minimize undersupply of a 
commodity while avoiding excessive oversupply. 
This is demonstrated in Section \ref{sec:demo}. 

\subsection{Facility Preference and Fleet Share}

The user has the option to give time-dependent preference 
equations to facilities' that supply the same commodity. 
If there are two reactor types, \glspl{LWR} and \glspl{SFR}, in a simulation, 
the user can make use of time-dependent 
preferences to make the simulation deploy LWRs at earlier times 
in the simulation, and deploy SFRs at later times in the 
simulation when there is a power demand. 
In table \ref{tab:inputs}, 
the LWR has a preference of $100-t$, and the 
SFR has a preference of $t-99$. 
$t$ refers to the month timestep. 
At time step 1, LWR preference becomes 99, while SFR preference becomes -98; 
therefore a LWR is deployed if there is a commodity shortage. 
At time step 100, LWR preference becomes 0, while SFR preference becomes 1; 
therefore a SFR is deployed if there is a commodity shortage. 
Thus, the transition occurs at the $100^{th}$ time step.

The user also has the option to specify percentage-share for facilities 
that provide the same commodity. 
For example, if there are two reactor types, \gls{MOX} LWRs and SFRs, in a simulation,
the user can make use of percentage-share specifications to determine the 
percentage of power supplied by each reactor.   
When MOX LWR has a share of $s\%$ and 
\gls{SFR} has a share of $(100-s)\%$, 
MOX LWR deployment constrains to $s\%$ of total power demand 
and SFR deployment constrains to $(100-s)\%$ of total power demand.  

The year the transition begins is selected by customizing facility 
preferences to begin preference for advanced reactors at a certain year,
and the sharing capability determines the percentage 
share of each type of reactor to transition to. 
Therefore, when \deploy predicts an undersupply of a commodity 
it deploys facilities in order of preference, starting at 
the highest and moving down if the facility percentage share 
is already met. 
If a facility type does not have any preferences, \deploy 
deploys available facilities to minimize the number of deployed 
facilities and oversupply of the commodity.


Figure \ref{fig:deployflow} shows the logical flow of how \deploy 
selects which facility to deploy when there are multiple facilities 
offering the same commodity. 

\begin{figure}[]
	\centering
	\resizebox{\textwidth} {0.8\height}{
    \begin{tikzpicture}[node distance=2.5cm]
    \tikzstyle{every node}=[font=\large]
	\node (pref)[olblock]{\textbf{Are there facility preferences?}};
	\node (fs1) [oblock, below of=pref, xshift = -3.5cm]{\textbf{Are there fleet share constraints?}};
	\node (fs2) [oblock, right of=fs1, xshift = 3.5cm]{\textbf{Are there fleet share constraints?} };
	\node (fs2yes) [bbmlock, below of=fs2, xshift = -2cm] {\textbf{Deploy facilities to meet fleet share $\%$}};
	\node (fs2no) [bbmlock, right of=fs2yes, xshift = 2cm, yshift=-1.07cm] {\textbf{Deploy facilities to minimize total no. of facilities and minimize oversupply.}};
	\node (fs1yes) [bbmmlock, below of=fs1, xshift = -2cm, yshift=-3cm] {\textbf{Deploy facilities in preference order to meet their fleet share \%}};
	\node (fs1no) [bbmlock, right of=fs1yes, xshift = 2cm] {\textbf{Deploy facility with highest preference}};
    \draw [arrow] (pref) -- node[anchor=east] {yes} (fs1);
	\draw [arrow] (pref) -- node[anchor=west] {no} (fs2);
	\draw [arrow] (fs2) -- node[anchor=east] {yes} (fs2yes);
	\draw [arrow] (fs2) -- node[anchor=west] {no} (fs2no);
	\draw [arrow] (fs1) -- node[anchor=east] {yes} (fs1yes);
	\draw [arrow] (fs1) -- node[anchor=west] {no} (fs1no);
	\end{tikzpicture}
	}
    \caption{Logical flow of how \deploy 
	selects which facility to deploy when there are multiple facilities 
	offering the same commodity.}
	\label{fig:deployflow}
\end{figure}

\subsection{Prediction Methods}
\deploy records supply and demand values at each time step for all 
commodities to provide time-series data for \deploy's time series 
forecasting methods to predict future supply and demand for each 
commodity.  
The time series forecasting methods investigated include non-optimizing, 
deterministic-optimizing, and stochastic-optimizing methods. 
Non-optimizing methods are techniques that harness 
simple moving average and autoregression concepts which use 
historical data to infer future supply and demand values. 
Deterministic-optimizing and stochastic-optimizing 
methods are techniques 
that use an assortment of more sophisticated time series forecasting 
concepts to predict future supply and demand values. 
Deterministic-optimizing methods give deterministic solutions,
while stochastic-optimizing methods give stochastic solutions. 

Depending on the scenario in question, each forecasting method 
offers distinct benefits and disadvantages.
The various methods are compared for each type of simulation 
to determine the most effective prediction method for 
a given scenario. 
The following sections describe the prediction methods. 

\subsubsection{Non-Optimizing Methods}
Non-optimizing methods include: Moving Average (\texttt{MA}), 
Autoregressive Moving Average (\texttt{ARMA}), and 
Autoregressive Heteroskedasticity (\texttt{ARCH}). 
The \texttt{MA} method calculates the average of 
a user-defined number of previous entries in a commodity's 
time series and returns it as the predicted value 
(equation \ref{eq:ma}).

\begin{align}
	\label{eq:ma}
	Predicted\ Value &= \frac{V_1+V_2+...+V_n}{n}
	\intertext{where:}
	V &= \mbox{Time series value} \nonumber\\
	n &= \mbox{length of timeseries} \nonumber\\
\end{align}

The \texttt{ARMA} method combines moving average and
autoregressive models (equation \ref{eq:arma}).
The first term is a constant, second term is 
white noise, the third term is the autoregressive
model, and the fourth term is the moving average
model.
The \texttt{ARMA} method is more accurate than the 
\texttt{MA} method 
because of the inclusion of the autoregressive term. 

\begin{align}
	\label{eq:arma}
	X_t &= c + \epsilon_t + 
	\sum_{i=1}^p\varphi_i X_{t-i} +	
	\sum_{i=1}^q\theta_i\epsilon_{t-i}
	\intertext{where:}
	c &= \mbox{constant} \nonumber\\
	\varphi &= \mbox{parameters} \nonumber\\
	\epsilon_t &= \mbox{white noise} \nonumber\\
	p &= \mbox{equation order} \nonumber \\
\end{align}

The \texttt{ARCH} method modifies the original moving 
average term (described in equation \ref{eq:arma}). 
This modification makes the \texttt{ARCH} method 
better than the \texttt{ARMA} method for volatile 
time-series data \cite{flanagan_methods_2019}. 
The StatsModels \cite{github_community_statsmodels:_2019}
Python package is used to implement \texttt{ARMA} and 
\texttt{ARCH} methods in \deploy. 

\subsubsection{Deterministic-Optimizing Methods}
Deterministic methods include
Fast Fourier Transform (\texttt{FFT}), 
Polynomial Fit (\texttt{POLY}), 
Exponential Smoothing (\texttt{EXP-SMOOTHING}), 
and Triple Exponential Smoothing (\texttt{HOLT-WINTERS}). 
The \texttt{FFT} method computes the discrete Fourier transform 
of the time series to predict future demand and supply 
values (equation \ref{eq:fft}).
This method is implemented in \deploy using the 
SciPy \cite{jones_scipy:_2016} Python package. 

\begin{align}
	\label{eq:fft}
	X_k &= \sum_{n=0}^{N-1}x_n e^{-i2\pi kn/N}
	\intertext{where:}
	k &= 0, ..., N-1 \nonumber\\
	N &= \mbox{No. of data points} \nonumber
\end{align}

The \texttt{POLY} method models the time series data 
with a user-defined nth degree polynomial to determine 
future demand and supply values. 
This method was implemented in \deploy using the 
NumPy \cite{developers_numpy_2013} Python package. 
The \texttt{EXP-SMOOTHING} and \texttt{HOLT-WINTERS} 
methods use a weighted average 
of time-series data with exponentially decaying weights 
for older time series values \cite{hyndman_forecasting:_2018}
to create a model to determine future demand and supply values. 
The \texttt{EXP-SMOOTHING} method excels in 
modeling univariate time series data without trend or seasonality, 
whereas the \texttt{HOLT-WINTERS} method applies exponential 
smoothing three times, resulting in higher accuracy when 
modeling seasonal time series data. 
The StatsModels \cite{github_community_statsmodels:_2019}
Python package was used to implement both of these methods 
in \deploy. 

\subsection{Stochastic-Optimizing Methods}
There is one stochastic-optimizing method: step-wise 
seasonal method (\texttt{SW-SEASONAL}). 
The method was implemented in \deploy by the auto \gls{ARIMA} 
method in the pmdarima \cite{noauthor_pmdarima:_2019}
Python package. 
The \gls{ARIMA} model is a generalization of the \gls{ARMA}
model to make the model fit the time series data better. 

